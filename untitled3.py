# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xnG7iPUegPH0GYRj3G2jnmqZYLeIAKSb
"""

def fact(x):
  if x == 0:
    return 1
  else:
    return x * fact(x-1)

print("请输入数字")
x = int(input())
print(fact(x))



print("请输入数字")
n=int(input())
d=dict()
for i in range(1,n+1):
    d[i]=i*i
print(d)

import re
print ("请输入序列")
value=input()
l=value.split(",")
k=re.findall(r'[0-9]+',value)
t=tuple(k)
print(k)
print(t)

class I

class MyClass:
  # def __init__(self):
  #   self.s = ""

  def getString(self):
    self.s = input("请输入一个字符串: ")

  def printString(self):
    print(self.s.upper())

# 测试函数
def test_my_class():
  my_object = MyClass()
  my_object.getString()
  my_object.printString()

test_my_class()

def generate_matrix(m, n):
  """
  生成一个 m 行 n 列的矩阵，其中位于 i 行 j 列的数字为 i * j。

  Args:
    m: 矩阵的行数。
    n: 矩阵的列数。

  Returns:
    一个 m x n 的列表，表示生成的矩阵。
  """
  matrix = []
  for i in range(m):
    row = []
    for j in range(n):
      row.append(i * j)
    matrix.append(row)
  return matrix

# 示例用法
print("请输入矩阵的行数 (m):")
m_value = int(input())
print("请输入矩阵的列数 (n):")
n_value = int(input())

result_matrix = generate_matrix(m_value, n_value)
for row in result_matrix:
  print(row)

item = [x for x in input().split(",")]
item.sort()
print(','.join(item))

lines=[]
while True:
    s=input()
    if s:
        lines.append(s.upper())
    else:
        break
for sentence in lines:
    print(sentence)

print('请输入单词')
s=input()
words=[word for word in s.split(" ")]
print(" ".join(sorted(list(set(words)))))

value=[]
print('请输入数字')
items=[x for x in input().split(',')]
for p in items:
    intp=int(p,2)
    if not intp%5:
        value.append(p)
print(','.join(value))

value=[]
for i in range(1000,3001):
  s = str(i)
  # Check if each digit is even by converting the character to an integer first
  if (int(s[0]) % 2 == 0) and \
     (int(s[1]) % 2 == 0) and \
     (int(s[2]) % 2 == 0) and \
     (int(s[3]) % 2 == 0):
    value.append(s)
print(",".join(value))

print('请输入')
s=input()
d={'DIGITS':0,'LETTERS':0}
for c in s:
    if c.isdigit():
        d['DIGITS']+=1
    elif c.isalpha():
        d['LETTERS']+=1
    else:
        pass
print('字母',d['LETTERS'])
print('数字',d['DIGITS'])

print('请输入')
s=input()
dict={'Upper case':0,'Lower case':0}
for c in s:
  if c.isupper():
    dict['Upper case']+=1
  elif c.islower():
    dict['Lower case']+=1
  else:
    pass
print('UPPER CASE',dict['Upper case'])
print('LOWER CASE',dict['Lower case'])

print('请输入数字')
a = input()
numbers = [int(a * i) for i in range(1, 5)]
print(sum(numbers))

print('请输入数字')
value = input()
items = [x for x in value.split(',') if int(x)%2!=0 ]
print(','.join(items))

class A:
    def greet(self):
        print("A")

class B(A):
    def greet(self):
        super().greet()
        print("B")

class C(A):
    def greet(self):
        super().greet()
        print("C")

class D(B, C):   # MRO: D → B → C → A → object
    def greet(self):
        super().greet()
        print("D")

d = D()
d.greet()

from operator import itemgetter,attrgetter
l=[]
print('请输入')
while True:
  s=input()
  if not s:
    break
  l.append(tuple(s.split(',')))
print (sorted(l,key=itemgetter(0,1,2)))

class DivisibleBySeven:
    """
    一个生成器类，用于迭代给定范围内（0到n）可被7整除的数字。
    """
    def __init__(self, n):
        self.n = n
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        while self.current <= self.n:
            if self.current % 7 == 0:
                temp = self.current
                self.current += 1
                return temp
            else:
                self.current += 1
        raise StopIteration

# 示例用法：
n = int(input("请输入范围上限 n: "))
for num in DivisibleBySeven(n):
    print(num)

freq = {}
print ('请输入')
line = input()
for word in line.split():
  freq[word] = freq.get(word, 0) + 1
words = sorted(freq.keys())
for w in words:
  print('%s:%d' % (w, freq[w]))

def square():
  return lambda n: n**2
print('请输入数字')
s=square()
n=int(input())
print(s(n))

def prictvale(s1,s2):
  len1=len(s1)
  len2=len(s2)
  if len1>len2:
    print(s1)
  elif len2>len1:
    print(s2)
  else:
    print(s1)
    print(s2)
print('请输入')
s1=input()
s2=input()
prictvale(s1,s2)

def checkvale(n):
  if int(n)%2==0:
    print('他为偶数')
  else:
    print ('他为奇数')
print('请输入数字')
s=input()
checkvale(s)

def printlist():
  li=list()
  for i in range(1,21):
    li.append(i**2)
  print(li[:5])
printlist()

def printTuple():
  li=list()
  for i in range(1,21):
    li.append(i**2)
  print(tuple(li[:5]))
printTuple()

tp=(1,2,3,4,5,6,7,8,9,10)
tp1=[tp[i] for i in range(0,5)]
tp2=[tp[i] for i in range(5,10)]
print(f"{tp1}\n{tp2}")

tp=(1,2,3,4,5,6,7,8,9,10)
li=list()
for i in range(len(tp)):
  if tp[i]%2==0:
    li.append(tp[i])
print(tuple(li))

print('请输入单词')
s=input()
if s=='yes' or s=='YES' or s=='Yes':
  print('Yes')
else:
  print('No')

li=[1,2,3,4,5,6,7,8,9,10]
evennumber=filter(lambda x:x%2==0,li)
for even in evennumber:
  print(even)

li=[1,2,3,4,5,6,7,8,9,10]
square=map(lambda x:x**2,li)
# Convert the map object to a list to display the squared numbers
print(list(square))

li1=[x for x in range(0,21)]
evennumber = filter(lambda x: x % 2 == 0, li1)
squared_even_numbers = map(lambda x: x**2, evennumber)
print(list(squared_even_numbers))

class American(object):
  pass
  @staticmethod
  def printNationality():
    print('American')
anAmerican=American()
anAmerican.printNationality()
American.printNationality()

class American(object):
  pass
  @staticmethod
  def printNationality1(name):
    print(f'American: {name}')

class NewYorker(American):
  pass
  @staticmethod
  def printNationality2(name):
    print(f'New Yorker: {name}')

anAmerican=American()
aNewYorker=NewYorker()

# Pass names when calling the static methods
anAmerican.printNationality1("Alice")
aNewYorker.printNationality2("Bob")

print(anAmerican)
print(aNewYorker)

class American(object):
  pass
  def printNationality1(self, name): # 加入 self 参数
    print(f'American: {name}')

class NewYorker(American):
  pass
  def printNationality2(self, name): # 加入 self 参数
    print(f'New Yorker: {name}')

anAmerican = American()
aNewYorker = NewYorker()

# 调用方式不变，但内部机制变了，实例 anAmerican 和 aNewYorker 会作为 self 传递
anAmerican.printNationality1("Alice")
aNewYorker.printNationality2("Bob")

print(anAmerican)
print(aNewYorker)

class Circle(object):
  def __init__(self,r):
    self.r=r
  def area(self):
    return self.r**2*3.14
aCircle=Circle(2)
print(aCircle.area())

class Rectangle():
  def __init__(self,l,w):
    self.l=l
    self.w=w
  def area(self):
    return self.l*self.w
aRectangle=Rectangle(2,10)
print(aRectangle.area())

class Shape(object):
  pass
  def area(self):
    return 0
class Square(Shape):
  def __init__(self,l):
    self.l=l
  def area(self):
    return self.l*self.l
aSquare=Square(3)
print(aSquare.area())

def thows():
  raise Exception("出错了")
try:
  thows()
except Exception as e:
  print(e)

class MyError(Exception):
  def __init__(self,msg):
    self.msg=msg
error=MyError("出错了")
print(error)

import re
print('请输入电子邮件')
emailaddress=input()
part2='(\w+)@((\w+\.)+(com))'
r2=re.match(part2,emailaddress)
print(r2.group(1))

import re
print('请输入电子邮件')
emailaddress=input()
part2='(\w+)@((\w+\.)+(com))'
r2=re.match(part2,emailaddress)
print(r2.group(2))

import re
print('请输入句子')
s=input()
part='(\d)'
r1=re.findall(part,s)
print(r1)

name = input("请输入名字: ") # 获取 name 的值
s=f"输入的是{name}"
enc=s.encode('utf-8')
dec=enc.decode('utf-8')
print(enc)
print(dec)

n=int(input())
sum=0.0
for i in range(1,n+1):
  sum+=float(float(i)/(i+1))
print(sum)

def f(n):
  if n==0: return 0
  elif n==1: return 1
  else: return f(n-1)+f(n-2)
n=int(input())
print(f(n))

def f(n):
  i=0
  while i<=n:
    if i%2==0:
      yield i
    i+=1

n=int(input())
value=[]
for i in f(n):
  value.append(str(i))
print(','.join(value))

def f(n):
 for i in range(n+1):
    if i%35==0:
      yield i

n=int(input())
value=[]
for i in f(n):
  value.append(str(i))
print(','.join(value))

li=[2,4,6,8]
for i in li:
  assert i%2==0

e=input()
print(eval(e))

import random
random.randint(a=1,b=100)



import random

# 获取用户输入的两个数字
print("请输入第一个数字 (a):")
a = float(input())
print("请输入第二个数字 (b):")
b = float(input())

# 生成介于 a 和 b 之间的随机浮点数
random_float = random.uniform(a, b)

# 打印结果
print(f"在 {a} 和 {b} 之间生成的随机浮点数是: {random_float}")

import zlib
print('请输入句子')
s=input()
t=zlib.compress(s.encode()) # Compress expects bytes, so encode the string
print(t)
print(zlib.decompress(t))

from timeit import Timer
t=Timer('for i in range(100):1+1')
print(t.timeit())



import random

# 创建一副扑克牌
suits = ["红桃", "方块", "梅花", "黑桃"]
ranks = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"]
deck = []
for suit in suits:
    for rank in ranks:
        deck.append(suit + rank)

# 添加大小王
deck.append("大王")
deck.append("小王")

# 打印洗牌前的扑克牌
print("洗牌前：")
print(deck)

# 洗牌
random.shuffle(deck)

# 打印洗牌后的扑克牌
print("\n洗牌后：")
print(deck)

# 分发扑克牌给三位玩家 (每人17张)
player1_hand = deck[0:17]
player2_hand = deck[17:34]
player3_hand = deck[34:51]

# 剩余的三张牌 (地主牌)
landlord_cards = deck[51:]

# 随机选择一位地主
landlord_index = random.randint(1, 3)

# 将地主牌分配给随机选出的地主
if landlord_index == 1:
    player1_hand.extend(landlord_cards)
    landlord_player = "玩家1"
elif landlord_index == 2:
    player2_hand.extend(landlord_cards)
    landlord_player = "玩家2"
else:
    player3_hand.extend(landlord_cards)
    landlord_player = "玩家3"


# 打印每位玩家的牌和地主
print("\n玩家1 的牌：")
print(player1_hand)

print("\n玩家2 的牌：")
print(player2_hand)

print("\n玩家3 的牌：")
print(player3_hand)

print(f"\n地主是: {landlord_player}")

sub=['I','You']
v=['Play','Love']
obj=['Hockey','Football']
for i in range(len(sub)):
 for j in range(len(v)):
  for k in range(len(obj)):
   sentence='%s%s%s.'%(sub[i],v[j],obj[k])
   print(sentence)



"""# Task
根据所给的三个不超过9的数字，生成一个三维数组并将其可视化为一个长方体。

## 获取用户输入

### Subtask:
从用户那里获取三个不超过 9 的整数，作为三维数组的维度。

**Reasoning**:
Get three integer inputs from the user, ensuring each is no more than 9.
"""

while True:
  try:
    dim1 = int(input("请输入第一个维度 (不超过9): "))
    dim2 = int(input("请输入第二个维度 (不超过9): "))
    dim3 = int(input("请输入第三个维度 (不超过9): "))
    if dim1 <= 9 and dim2 <= 9 and dim3 <= 9:
      break
    else:
      print("输入的维度不能超过9，请重新输入。")
  except ValueError:
    print("输入无效，请输入整数。")

"""## 创建三维数组

### Subtask:
使用用户输入的维度创建一个三维数组，可以使用嵌套列表或 NumPy 数组。

**Reasoning**:
Create a 3D list using nested loops based on the obtained dimensions and initialize elements to 0.
"""

three_d_array = []
for i in range(dim1):
  two_d_layer = []
  for j in range(dim2):
    one_d_row = []
    for k in range(dim3):
      one_d_row.append(0)
    two_d_layer.append(one_d_row)
  three_d_array.append(two_d_layer)

# Print the first few elements to verify
print("Generated 3D array (first layer):")
for row in three_d_array[0]:
  print(row)

"""## 选择可视化库

### Subtask:
确定一个适合在 Colab 中进行三维可视化的 Python 库，例如 `matplotlib` 或 `plotly`。

## 准备可视化数据

### Subtask:
将三维数组转换为可视化库所需的格式。

**Reasoning**:
Convert the nested list to a numpy array, define the vertices and edges of the cuboid based on the array's dimensions, and store them in numpy arrays.
"""

import numpy as np

# Convert the nested list to a NumPy array
numpy_array = np.array(three_d_array)

# Determine the dimensions of the NumPy array
x_dim, y_dim, z_dim = numpy_array.shape

# Define the vertices of the cuboid based on the array dimensions
# The vertices represent the corners of the cuboid
vertices_x = np.array([0, x_dim, x_dim, 0, 0, x_dim, x_dim, 0])
vertices_y = np.array([0, 0, y_dim, y_dim, 0, 0, y_dim, y_dim])
vertices_z = np.array([0, 0, 0, 0, z_dim, z_dim, z_dim, z_dim])

# Define the edges by specifying the start and end vertices for each edge
# This defines the framework of the cuboid
edges_x = np.array([
    [vertices_x[0], vertices_x[1]], [vertices_x[1], vertices_x[2]],
    [vertices_x[2], vertices_x[3]], [vertices_x[3], vertices_x[0]],
    [vertices_x[4], vertices_x[5]], [vertices_x[5], vertices_x[6]],
    [vertices_x[6], vertices_x[7]], [vertices_x[7], vertices_x[4]],
    [vertices_x[0], vertices_x[4]], [vertices_x[1], vertices_x[5]],
    [vertices_x[2], vertices_x[6]], [vertices_x[3], vertices_x[7]]
]).T # Transpose to get shape (2, 12)

edges_y = np.array([
    [vertices_y[0], vertices_y[1]], [vertices_y[1], vertices_y[2]],
    [vertices_y[2], vertices_y[3]], [vertices_y[3], vertices_y[0]],
    [vertices_y[4], vertices_y[5]], [vertices_y[5], vertices_y[6]],
    [vertices_y[6], vertices_y[7]], [vertices_y[7], vertices_y[4]],
    [vertices_y[0], vertices_y[4]], [vertices_y[1], vertices_y[5]],
    [vertices_y[2], vertices_y[6]], [vertices_y[3], vertices_y[7]]
]).T

edges_z = np.array([
    [vertices_z[0], vertices_z[1]], [vertices_z[1], vertices_z[2]],
    [vertices_z[2], vertices_z[3]], [vertices_z[3], vertices_z[0]],
    [vertices_z[4], vertices_z[5]], [vertices_z[5], vertices_z[6]],
    [vertices_z[6], vertices_z[7]], [vertices_z[7], vertices_z[4]],
    [vertices_z[0], vertices_z[4]], [vertices_z[1], vertices_z[5]],
    [vertices_z[2], vertices_z[6]], [vertices_z[3], vertices_z[7]]
]).T

# Print the shapes of the created numpy arrays to verify
print("Shape of numpy_array:", numpy_array.shape)
print("Shape of vertices_x:", vertices_x.shape)
print("Shape of vertices_y:", vertices_y.shape)
print("Shape of vertices_z:", vertices_z.shape)
print("Shape of edges_x:", edges_x.shape)
print("Shape of edges_y:", edges_y.shape)
print("Shape of edges_z:", edges_z.shape)

"""## 生成长方体可视化

### Subtask:
使用选定的可视化库创建长方体的可视化表示，可能需要绘制每个面或使用体渲染技术。

**Reasoning**:
Import the necessary modules, create a figure and 3D axes, plot the cuboid edges, set axis labels and limits, and set the plot title.
"""

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

# Plot the edges of the cuboid
for i in range(edges_x.shape[1]):
    ax.plot(edges_x[:, i], edges_y[:, i], edges_z[:, i], color='b')

# Set labels
ax.set_xlabel('X-axis')
ax.set_ylabel('Y-axis')
ax.set_zlabel('Z-axis')

# Set limits to encompass the dimensions
ax.set_xlim([0, x_dim])
ax.set_ylim([0, y_dim])
ax.set_zlim([0, z_dim])

# Set title
ax.set_title('3D Array as a Cuboid')

plt.show()

"""## 显示可视化结果

### Subtask:
在 Colab 中显示生成的三维长方体可视化。

## Summary:

### Data Analysis Key Findings

*   The process successfully obtained three integer dimensions (3, 4, and 3) from the user, each not exceeding 9.
*   A 3D array was created using nested lists with the dimensions 3x4x3, and the first layer was printed for verification.
*   The `matplotlib.pyplot` library with the `mplot3d` toolkit was selected for 3D visualization in Google Colab.
*   The nested list 3D array was converted to a NumPy array of shape (3, 4, 3).
*   NumPy arrays were created to define the vertices (shape 8,) and edges (shape 2, 12) of a cuboid based on the array dimensions.
*   A 3D plot of the cuboid's edges was successfully generated and displayed using `matplotlib`, with appropriate axis labels, limits, and title.

### Insights or Next Steps

*   The current visualization shows the framework of the 3D array as a cuboid. A next step could involve adding visual cues to represent the individual cells within the 3D array, perhaps using scattered points or translucent cubes.
*   For more interactive visualization, especially with larger arrays or more complex structures, exploring libraries like `plotly` would be beneficial as it supports interactive features directly within Colab.

# Task
根据用户提供的三个不超过9的整数，生成一个对应维度的三维数组，随机填充数组元素，并使用可视化方式展示该三维数组，其中元素值越大，可视化中的颜色越深。

## 获取用户输入

### Subtask:
从用户那里获取三个不超过 9 的整数，作为三维数组的维度。

**Reasoning**:
Get three integer inputs from the user, ensuring each is no more than 9.
"""

while True:
  try:
    dim1 = int(input("请输入第一个维度 (不超过9): "))
    dim2 = int(input("请输入第二个维度 (不超过9): "))
    dim3 = int(input("请输入第三个维度 (不超过9): "))
    if dim1 <= 9 and dim2 <= 9 and dim3 <= 9:
      break
    else:
      print("输入的维度不能超过9，请重新输入。")
  except ValueError:
    print("输入无效，请输入整数。")

"""## 创建三维数组

### Subtask:
使用用户输入的维度创建一个三维数组，可以使用嵌套列表或 NumPy 数组。

**Reasoning**:
Create a 3D list using nested loops based on the obtained dimensions and initialize elements to 0.
"""

three_d_array = []
for i in range(dim1):
  two_d_layer = []
  for j in range(dim2):
    one_d_row = []
    for k in range(dim3):
      one_d_row.append(0)
    two_d_layer.append(one_d_row)
  three_d_array.append(two_d_layer)

# Print the first few elements to verify
print("Generated 3D array (first layer):")
for row in three_d_array[0]:
  print(row)

"""## 随机填充数组

### Subtask:
随机生成数字填充三维数组的每个元素。

**Reasoning**:
Import the random module and then iterate through the 3D array to fill it with random integers.
"""

import random

for i in range(dim1):
  for j in range(dim2):
    for k in range(dim3):
      three_d_array[i][j][k] = random.randint(0, 255)

# Print the first few elements to verify
print("Generated 3D array with random values (first layer):")
for row in three_d_array[0]:
  print(row)

"""## 选择可视化库

### Subtask:
确定一个适合在 Colab 中进行三维可视化的 Python 库，例如 `matplotlib` 或 `plotly`。

## 准备可视化数据

### Subtask:
将三维数组转换为可视化库所需的格式，并准备用于颜色映射的数据。

**Reasoning**:
Convert the nested list to a numpy array, then flatten it to prepare for color mapping.
"""

import numpy as np

numpy_array = np.array(three_d_array)

# Flatten the numpy array to get a list of all values for color mapping
flattened_values = numpy_array.flatten().tolist()

# Print the shape of the numpy array and the first few flattened values to verify
print("Shape of numpy_array:", numpy_array.shape)
print("First 10 flattened values:", flattened_values[:10])

"""## 生成三维可视化

### Subtask:
使用选定的可视化库创建三维数组的可视化表示，通过颜色深浅反映元素值的大小。

**Reasoning**:
Import necessary modules, create a 3D scatter plot using plotly, define coordinates and color based on the flattened array, set the mode to markers, configure the layout, and display the plot.
"""

import plotly.graph_objects as go

# Get the indices for each element in the 3D array
x_coords, y_coords, z_coords = np.indices(numpy_array.shape)

# Flatten the indices to match the flattened values
x_coords_flat = x_coords.flatten()
y_coords_flat = y_coords.flatten()
z_coords_flat = z_coords.flatten()

# Create the 3D scatter plot
fig = go.Figure(data=[go.Scatter3d(
    x=x_coords_flat,
    y=y_coords_flat,
    z=z_coords_flat,
    mode='markers',
    marker=dict(
        size=5,
        color=flattened_values,  # Color points based on the flattened values
        colorscale='Viridis',  # Use the Viridis colormap
        opacity=0.8
    )
)])

# Configure the layout
fig.update_layout(
    title='3D Array Visualization',
    scene=dict(
        xaxis_title='X-axis',
        yaxis_title='Y-axis',
        zaxis_title='Z-axis'
    ),
    margin=dict(l=0, r=0, b=0, t=40)
)

# Display the plot
fig.show()

"""## 显示可视化结果

### Subtask:
在 Colab 中显示生成的三维可视化。

## Summary:

### Data Analysis Key Findings

*   The process successfully obtained three integer dimensions (not exceeding 9) from the user.
*   A three-dimensional array (represented as a nested list and then converted to a NumPy array) was created with the specified dimensions.
*   The elements of the three-dimensional array were successfully filled with random integer values between 0 and 255.
*   `plotly` was chosen as the visualization library for its interactive features and ability to map data values to color intensity.
*   The three-dimensional array was visualized as a 3D scatter plot where the color of each point (using the 'Viridis' colormap) represents the value of the corresponding element in the array.

### Insights or Next Steps

*   Consider adding options for the user to choose the colormap used for visualization.
*   Explore other visualization techniques, such as a 3D heatmap or volume rendering, for representing the three-dimensional data.
"""

class person(object):
  def sex(self):
    return '我不到啊'

class male(person):
  def sex(self):
    return '男'
class female(person):
  def sex(self):
    return '女'

# 创建实例
aperson = person()
amale = male()
afemale = female()

# 调用 sex 方法
print(aperson.sex())
print(amale.sex())  # 调用 male 实例的 sex 方法
print(afemale.sex()) # 调用 female 实例的 sex 方法

i=1
while i<=9:
  j=1
  while j<=i:
    print('%d×%d=%-2d'%(i,j,i*j),end=' ')
    j+=1
  print()
  i+=1